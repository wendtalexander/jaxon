---
title: "Adaptive Exponential Integrate-and-Fire (AdEx)"
format:
  html:
    toc: true
    css: styles.css
    toc-title: Contents
    code-block-bg: true
    code-block-border-left: "#31BAE9"
    code-line-numbers: true
    highlight-style: atom-one
    link-external-icon: true
    link-external-newwindow: true
    eqn-number: true
---

## 1. Motivation
The Adaptive exponential Integrate-and-Fire model is a further increase in
complexity, but can inherently explain variation, that is seen in biological
systems. The main reson is this model can achive different bursting mechanisms, like regular bursting, 
inital bursts, and a combination of adaption.
The AdEx model consists instead of a linear integration a exponetial integration, with an adaptation current:

$$\tau_{m} \frac{dv}{dt} = -(v(t)-v_{rest}) + \Delta_{T}\,\exp(\frac{v(t)-\vartheta}{\Delta_T}) - RA(t) + RI(t)$$

where the adaptation is definded as:

$$\tau_{a} \frac{dA}{dt} = a(v-v_{rest}) - A + b\tau_{a}$$ 


## 2. Implementation
Implemented is this again with the Ohrnstein-Uhlenbeck form:

$$ \tau_{m}\frac{du}{dt} = -u(t)+ \Delta_{T}\,\exp(\frac{u(t)-\vartheta}{\Delta_T}) + - A(t) + \textrm{stimulus} + \sqrt{2D}\xi(t) $$

where first is the exponetial calculated and currently clipped at -500 and 500,
and after the voltage step the adaptation like this:

$$\tau_{a} \frac{dA}{dt} = a(v-v_{rest}) - A + b\tau_{a}$$ 

Like in the [LIF](lif.qmd) has a dataclass that holds the parameter needed for simulating the model:
[AdExParams](api/models.adex.qmd#jaxon.models.adex.AdExParams)


## 3. Example
Here is a minimal example that get you started.

```{python}
import jax
import jax.numpy as jnp
import jax.scipy as jsp

import jaxon.models.adex as adex

duration = 10
# parameters for LIF model
fs = 1000
threshold = 1
tau_mem = 0.01
exp_threshold = 1
exp_deltat = 0.01
tau_adapt = 2
deltat_adapt = 0.01
ref_period = 0.001
v_base = 0.0
noise_strength = 0.01
a = 0.1
b = 0.02

# parameter for kernel
sigma = 0.2
ktime = 4

# first generate a random key for the LIF model
key = jax.random.PRNGKey(42)
keys = jax.random.split(key, 10)
time = jnp.arange(0, duration, 1 / fs)
params = adex.AdExParams(
    fs=fs,
    threshold=threshold,
    tau_mem=tau_mem,
    tau_adapt=tau_adapt,
    v_base=v_base,
    ref_period=ref_period,
    deltat_adapt=deltat_adapt,
    noise_strength=noise_strength,
    a=a,
    b=b,
    exp_deltat=exp_deltat,
    exp_threshold=exp_threshold,
)

stimulus = jnp.ones_like(time)
binary_spikes, vmem = adex.simulate(key, stimulus, params)


def calc_spike_rate(binary_spike_train, kernel):
    return jsp.signal.fftconvolve(binary_spike_train, kernel, "same")


def gauss_kernel_jax(sigma, dt, k_time):
    x = jnp.arange(-k_time * sigma, k_time * sigma, dt)
    y = jnp.exp(-0.5 * (x / sigma) ** 2) / jnp.sqrt(2.0 * jnp.pi) / sigma
    return y


kernel = gauss_kernel_jax(sigma, 1 / fs, ktime)

rate = calc_spike_rate(binary_spikes, kernel)
```

We can now plot the simulation result of the LIF simulation.

```{python}
# | output: false
import plotly.graph_objects as go
from plotly.subplots import make_subplots

fig = make_subplots(specs=[[{"secondary_y": True}]])
fig.add_scatter(x=time, y=vmem, mode="lines", name="V", secondary_y=False)


fig.add_scatter(
    x=time[binary_spikes.astype(bool)],
    y=vmem[binary_spikes.astype(bool)] + threshold,
    mode="markers",
    marker_size=10,
    marker_color="red",
    marker_symbol="arrow-down",
    name="Spikes",
    secondary_y=False,
)
fig.add_scatter(
    x=time, y=rate, name="Rate [Hz]", secondary_y=True, marker_color="magenta", line_width=4
)

fig.update_layout(xaxis_title="Time [s]", yaxis_title="Volatage [aU]")
fig.update_yaxes(title_text="Rate [Hz]", secondary_y=True)
```

```{python}
# | echo: false
# | renderings: [light, dark]
fig.update_layout(template="plotly_white")
display(fig)
fig.update_layout(template="plotly_dark")
display(fig)
```
