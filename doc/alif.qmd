---
title: "Adaptive Leaky Integrated-and-Fire-Model with refractory period (aLIF)"
format:
  html:
    toc: true
    css: styles.css
    toc-title: Contents
    code-block-bg: true
    code-block-border-left: "#31BAE9"
    code-line-numbers: true
    highlight-style: atom-one
    link-external-icon: true
    link-external-newwindow: true
    eqn-number: true
---

## 1. Motivation
The adaptive leaky Integrate-and-Fire Model with a refractory period is an
extension of the normal [LIF](lif.qmd) model. Where the adaption is another
time dependent differential equation:

$$\tau_{a} \frac{dA}{dt} = -A$$ {#eq-adap}

Which can be motivated by firing rate adaption. At the beginning a given
stimulus the neuron fires rapidly but slows down even if the current is
unchanged.

Refractory period is a time constant where the neuron is unable to generate
another spike. If this is omitted a LIF model can generate unrealistic high
firing rates, and is usually in the range of 1-2 ms.



## 2. Implementation
Adding the adaption current yields the following differential equation:

$$ \tau_{m}\frac{du}{dt} = -u(t)+ \mu  -A(t) + \sqrt{2D}\xi(t) $$
Where the adaption is defined in @eq-adap

During the refractory period there is no spike elicited.

Like in the [LIF](lif.qmd) has a dataclass that holds the parameter needed for simulating the model:
[ALIFRefParams](api/models.alif_ref.qmd)


## 3. Example
Here is a minimal example that get you started.

```{python}
import jax
import jax.numpy as jnp
import jaxon.models.alif as alif
import jax.scipy as jsp

# parameters for LIF model
fs = 1000
duration = 3
threshold = 1.0
v_offset = 0.5
tau_mem = 0.01
tau_adapt = 1
a_zero = 0.0
deltat_adapt=0.01
ref_period = 0.001
v_base = 0.0
noise_strength = 0.01

# parameter for kernel
sigma = 0.1
ktime = 4

# first generate a random key for the LIF model
key = jax.random.PRNGKey(42)
keys = jax.random.split(key, 10)
time = jnp.arange(0, duration, 1/fs)
params = alif.ALIFRefParams(fs=fs, threshold=threshold, v_offset=v_offset,
                            tau_mem=tau_mem, tau_adapt= tau_adapt,
                            a_zero=a_zero, v_base=v_base,ref_period=ref_period,
                            deltat_adapt=deltat_adapt,
                            noise_strength=noise_strength)
stimulus = jnp.ones_like(time)
binary_spikes, vmem = alif.simulate(key, stimulus, params)


def calc_spike_rate(binary_spike_train, kernel):
    return jsp.signal.fftconvolve(binary_spike_train, kernel, "same")

def gauss_kernel_jax(sigma, dt, k_time):
    x = jnp.arange(-k_time * sigma, k_time * sigma, dt)
    y = jnp.exp(-0.5 * (x / sigma) ** 2) / jnp.sqrt(2.0 * jnp.pi) / sigma
    return y

kernel = gauss_kernel_jax(sigma, 1/fs,ktime)

rate = calc_spike_rate(binary_spikes, kernel)
```

We can now plot the simulation result of the LIF simulation.

```{python}
import plotly.graph_objects as go 
from plotly.subplots import make_subplots

fig = make_subplots(specs=[[{"secondary_y": True}]])
fig.add_scatter(x=time, y=vmem, mode='lines', name="V", secondary_y=False)


fig.add_scatter(x=time[binary_spikes.astype(bool)],
                y=vmem[binary_spikes.astype(bool)]+threshold, mode='markers',
                marker_size=10, marker_color="red", marker_symbol="arrow-down",
                name="Spikes", secondary_y=False)
fig.add_scatter(x=time, y=rate, name="Rate [Hz]", secondary_y=True, marker_color="black")

fig.update_layout(xaxis_title="Time [s]", yaxis_title="Volatage [aU]")
fig.update_yaxes(title_text="Rate [Hz]", secondary_y=True)
```
